{"version":3,"file":"385.bundle.js","mappings":"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","sources":["webpack://client/./src/services/networkThrottleService.js"],"sourcesContent":["// Store original methods ONCE at module load (before any interception)\nconst ORIGINAL_FETCH = window.fetch;\nconst ORIGINAL_XHR_OPEN = XMLHttpRequest.prototype.open;\nconst ORIGINAL_XHR_SEND = XMLHttpRequest.prototype.send;\n\nclass NetworkThrottleService {\n  constructor() {\n    this.isEnabled = false;\n    this.latency = 0;\n    this.downloadSpeed = Infinity;\n    this.uploadSpeed = Infinity;\n    this.originalFetch = ORIGINAL_FETCH;\n    this.originalXHROpen = ORIGINAL_XHR_OPEN;\n    this.originalXHRSend = ORIGINAL_XHR_SEND;\n    this.isIntercepted = false;\n  }\n\n  // Enable network throttling\n  enable(config = {}) {\n    const {\n      latency = 100, // ms\n      downloadSpeed = 1024 * 1024, // 1MB/s\n      uploadSpeed = 512 * 1024, // 512KB/s\n      packetLoss = 0 // 0-1 percentage\n    } = config;\n\n    this.isEnabled = true;\n    this.latency = latency;\n    this.downloadSpeed = downloadSpeed;\n    this.uploadSpeed = uploadSpeed;\n    this.packetLoss = packetLoss;\n\n    // Only intercept if not already intercepted\n    if (!this.isIntercepted) {\n      this.interceptFetch();\n      this.interceptXHR();\n      this.isIntercepted = true;\n    }\n\n    console.log(`[Network Throttle] Enabled - Latency: ${latency}ms, Download: ${this.formatSpeed(downloadSpeed)}, Upload: ${this.formatSpeed(uploadSpeed)}`);\n  }\n\n  // Disable network throttling\n  disable() {\n    this.isEnabled = false;\n    \n    // Restore original methods using module-level originals\n    if (this.isIntercepted) {\n      window.fetch = ORIGINAL_FETCH;\n      XMLHttpRequest.prototype.open = ORIGINAL_XHR_OPEN;\n      XMLHttpRequest.prototype.send = ORIGINAL_XHR_SEND;\n      this.isIntercepted = false;\n    }\n  }\n\n  // Intercept fetch requests\n  interceptFetch() {\n    const service = this;\n    \n    window.fetch = async function(...args) {\n      if (!service.isEnabled) {\n        return ORIGINAL_FETCH.apply(window, args);\n      }\n\n      // Pre-send: latency + upload throttling\n      try {\n        const [, init] = args;\n        let uploadBytes = 0;\n        const body = init?.body;\n        if (body) {\n          if (body instanceof Blob) uploadBytes = body.size;\n          else if (typeof body === 'string') uploadBytes = body.length;\n          else if (body instanceof ArrayBuffer) uploadBytes = body.byteLength;\n          else if (ArrayBuffer.isView?.(body)) uploadBytes = body.byteLength;\n        }\n        const uploadDelayMs = (uploadBytes / service.uploadSpeed) * 1000;\n        const preSendDelay = Math.max(0, service.latency + (isFinite(uploadDelayMs) ? uploadDelayMs : 0));\n        if (preSendDelay > 0) await service.delay(preSendDelay);\n      } catch (_) {\n        // Fallback: latency only if upload size unknown\n        await service.delay(service.latency);\n      }\n\n      // Simulate packet loss before sending\n      if (Math.random() < service.packetLoss) {\n        throw new Error('Network Error: Packet Loss Simulated');\n      }\n\n      try {\n        const response = await ORIGINAL_FETCH.apply(window, args);\n\n        // Simulate download speed throttling for streaming bodies\n        if (response.body && isFinite(service.downloadSpeed)) {\n          const reader = response.body.getReader();\n          const chunks = [];\n          while (true) {\n            const { done, value } = await reader.read();\n            if (done) break;\n            chunks.push(value);\n            const chunkSize = value.length;\n            const delayTime = (chunkSize / service.downloadSpeed) * 1000;\n            if (delayTime > 0) await service.delay(delayTime);\n          }\n          const blob = new Blob(chunks);\n          return new Response(blob, {\n            status: response.status,\n            statusText: response.statusText,\n            headers: response.headers\n          });\n        }\n\n        // Non-streaming: approximate using Content-Length\n        const contentLengthHeader = response.headers?.get?.('content-length');\n        const contentLength = contentLengthHeader ? parseInt(contentLengthHeader, 10) : 0;\n        if (contentLength > 0 && isFinite(service.downloadSpeed)) {\n          const downloadDelayMs = (contentLength / service.downloadSpeed) * 1000;\n          if (downloadDelayMs > 0) await service.delay(downloadDelayMs);\n        }\n        return response;\n      } catch (error) {\n        console.error('[Network Throttle] Fetch error:', error);\n        throw error;\n      }\n    };\n  }\n\n  // Intercept XMLHttpRequest\n  interceptXHR() {\n    const service = this;\n\n    XMLHttpRequest.prototype.open = function(...args) {\n      this._throttleConfig = {\n        startTime: performance.now(),\n        url: args[1]\n      };\n      return ORIGINAL_XHR_OPEN.apply(this, args);\n    };\n\n    XMLHttpRequest.prototype.send = function(data) {\n      if (!service.isEnabled) {\n        return ORIGINAL_XHR_SEND.call(this, data);\n      }\n\n      const xhr = this;\n\n      // Packet loss: abort instead of mutating read-only props\n      if (Math.random() < service.packetLoss) {\n        setTimeout(() => {\n          try { xhr.abort(); } catch (_) {}\n        }, service.latency);\n        return;\n      }\n\n      // Compute upload size for delay\n      let uploadBytes = 0;\n      try {\n        if (data) {\n          if (data instanceof Blob) uploadBytes = data.size;\n          else if (typeof data === 'string') uploadBytes = data.length;\n          else if (data instanceof ArrayBuffer) uploadBytes = data.byteLength;\n          else if (ArrayBuffer.isView?.(data)) uploadBytes = data.byteLength;\n        }\n      } catch (_) {}\n\n      const uploadDelayMs = (uploadBytes / service.uploadSpeed) * 1000;\n      const preSendDelay = Math.max(0, service.latency + (isFinite(uploadDelayMs) ? uploadDelayMs : 0));\n\n      setTimeout(() => {\n        ORIGINAL_XHR_SEND.call(xhr, data);\n      }, preSendDelay);\n    };\n  }\n\n  // Utility method to add delay\n  delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  // Format speed for display\n  formatSpeed(bytesPerSecond) {\n    if (bytesPerSecond >= 1024 * 1024) {\n      return `${(bytesPerSecond / (1024 * 1024)).toFixed(1)}MB/s`;\n    } else if (bytesPerSecond >= 1024) {\n      return `${(bytesPerSecond / 1024).toFixed(1)}KB/s`;\n    } else {\n      return `${bytesPerSecond.toFixed(0)}B/s`;\n    }\n  }\n\n  // Get current status\n  getStatus() {\n    return {\n      isEnabled: this.isEnabled,\n      latency: this.latency,\n      downloadSpeed: this.downloadSpeed,\n      uploadSpeed: this.uploadSpeed,\n      packetLoss: this.packetLoss\n    };\n  }\n\n  // Preset configurations\n  static getPresets() {\n    return {\n      'Fast 3G': {\n        latency: 100,\n        downloadSpeed: 1.5 * 1024 * 1024, // 1.5MB/s\n        uploadSpeed: 750 * 1024, // 750KB/s\n        packetLoss: 0.01\n      },\n      'Slow 3G': {\n        latency: 300,\n        downloadSpeed: 780 * 1024, // 780KB/s\n        uploadSpeed: 330 * 1024, // 330KB/s\n        packetLoss: 0.02\n      },\n      '2G': {\n        latency: 500,\n        downloadSpeed: 250 * 1024, // 250KB/s\n        uploadSpeed: 50 * 1024, // 50KB/s\n        packetLoss: 0.05\n      },\n      'Dial-up': {\n        latency: 1000,\n        downloadSpeed: 56 * 1024, // 56KB/s\n        uploadSpeed: 33 * 1024, // 33KB/s\n        packetLoss: 0.1\n      }\n    };\n  }\n\n  // Instance helper to access presets from the singleton\n  getPresets() {\n    return NetworkThrottleService.getPresets();\n  }\n}\n\n// Create singleton instance\nconst networkThrottleService = new NetworkThrottleService();\n\nexport default networkThrottleService; "],"names":["ORIGINAL_FETCH","window","fetch","ORIGINAL_XHR_OPEN","XMLHttpRequest","prototype","open","ORIGINAL_XHR_SEND","send","NetworkThrottleService","constructor","this","isEnabled","latency","downloadSpeed","Infinity","uploadSpeed","originalFetch","originalXHROpen","originalXHRSend","isIntercepted","enable","config","arguments","length","undefined","packetLoss","interceptFetch","interceptXHR","console","log","concat","formatSpeed","disable","service","async","_len","args","Array","_key","apply","init","uploadBytes","body","_ArrayBuffer$isView","Blob","size","ArrayBuffer","isView","call","byteLength","uploadDelayMs","preSendDelay","Math","max","isFinite","delay","_","random","Error","_response$headers","_response$headers$get","response","reader","getReader","chunks","done","value","read","push","delayTime","blob","Response","status","statusText","headers","contentLengthHeader","get","contentLength","parseInt","downloadDelayMs","error","_len2","_key2","_throttleConfig","startTime","performance","now","url","data","xhr","setTimeout","abort","_ArrayBuffer$isView2","ms","Promise","resolve","bytesPerSecond","toFixed","getStatus","getPresets"],"sourceRoot":""}